---
title: "[Algorithm] 알고리즘 공부 1일차.."
date: 2022-01-02
categories: [Public]
tags: [algorithm]
---

_'프로그래밍 대회에서 배우는 알고리즘 문제해결 전략 - 구종만' 참조_  

---

#### 문제를 읽기 위한 6단계  

1. 문제를 읽고 이해한다.  
    - 가장 기초적이고 중요하지만 많은 사람들이 당연하다고 여겨 무시하게 되는 단계. 하지만 문제를 잘못 이해하면 문제를 푸는 의미가 없다. 문제에서 요구하는 조건과 제약사항을 명확히 이해하는 것이 중요.  
        * 나도 종종 문제를 풀며 가장 많은 실수를 하는 부분이 아닌가 생각된다. 대부분의 문제가 수학 공식처럼 명확하게 주어지기보단 주어진 글 속에서 문제의 요구사항을 파악해야 하다보니 어려움이 생기는 것 같다.  
2. 문제를 익숙한 용어로 재정의한다.  
    - 재정의와 추상화. 현실 시계의 개념을 우리가 다루기 쉬운 수학적/전산학적 개념으로 표현하는 과정. 추상화를 잘해야 문제를 쉽게 풀 수 있다.  
        * 사실 그동안 문제를 풀면서 가장 어려운 부분이다. 아직 경험이 부족해서인지 몰라도 문제를 보고 바로바로 추상화시켜서 간단하게 풀어내는 사람들을 보면 신기할 따름이다. 추상화를 하는 공식이 있는 것도 아니다보니 경험을 쌓는 것이 중요할 것 같다.  
3. 어떻게 해결할지 계획을 세운다.  
    - 추상화된 문제에 대해 어떤 자료구조와 알고리즘을 사용해서 문제를 풀지 정하는 단계이다. 사실상 가장 중요한 단계.  
        * 너무 어렵다. 문제 사이트는 보통 알고리즘 별로 문제를 나눠놓다보니 해당 카테고리에 맞는 알고리즘을 사용해서 문제를 풀기 마련인데, 실제 대회나 테스트 문제를 풀어보면 어떤 알고리즘과 자료구조를 사용해야 할지 전혀 모르겠는 경우가 많다. 이 역시 경험으로 해결해야 할 것 같다.  
4. 계획을 검증한다.  
    - 계획을 검증한다. 모든 요구조건을 만족할 수 있는지 파악하고, 이때 수행시간과 사용 메모리 역시 확인한다.  
        * 제대로 검증하지 않고 코드를 짜다가 문제를 파악하면 이미 돌이킬 수 없을 정도로 시간이 지나있을 수 있다. 검증을 철저히 하자.  
5. 프로그램으로 구현한다.  
    - 실질적인 코딩과정. 계획한 알고리즘을 구현한다.  
        * 알고리즘을 구체적으로 설계해서 구현중에 알고리즘을 변경하는 일이 없도록 한다. 오타 좀 그만 쳐 제발...  
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.  
    - 대회/테스트가 끝나고 자신의 문제풀이를 돌아보고 개선하는 과정. 실력향상을 위해선 가장 중요한 단계다.  
        * 고등학교때도 오답노트는 정말 하기 싫었는데.. 여기서도 해야한다니.. 우울하다..  


한 문제당 30분 정도 시간 정해놓고 그 안에 못풀면 답안을 참고하자. 아직 초보니까.. 계속 한 문제만 붙잡고 고민하는 것보다 다른 사람의 코드를 참조해서 공부하는 것이 도움이 될 수 있다.  
이러니 저러니 말을 했지만 사실 프로그래밍 문제 풀이에 제일 중요한 건 경험인 것 같다. 책에 있는 문제들부터 쭉 풀어보고 다양한 알고리즘을 익힌 뒤에 문제 사이트에서 닥치는 대로 많이 풀어보자. 문제풀이 실력은 물론 알고리즘, 자료구조에 대한 이해, 단순 코딩 능력도 좋아질 것이다. 아마도...  

---

#### 알고리즘의 시간 복잡도 분석  

 알고리즘은 빠른게 좋다. 다만 이 빠르기가 단순히 프로그램의 실행 시간만을 이야기 하는 것은 아니다. 프로그램의 실행 시간은 프로그래밍 언어, 하드웨어, 운영체제, 컴파일러 등 알고리즘 외적인 수많은 요소에 영향을 받기 때문이다.  
또한 입력의 크기나 특성에 따라 같은 알고리즘이라도 프로그램의 실행 시간은 변하기 마련이다.  
 알고리즘의 수행 시간은 반복문에 따라 결정된다. 대부분의 알고리즘은 입력 횟수에 따라 반복문의 수행 횟수 역시 달라진다. 이런 알고리즘들은 입력 횟수가 커지면 커질수록 반복문이 수행 시간에서 차지하는 비중이 증가한다. 따라서 대개 우리는 알고리즘의 수행 시간을 반복문이 수행되는 횟수로 측정한다.  

~~~cpp
int majority1(const vector<int>& A) {
    int N = A.size();
    int majority = -1, majorityCount = 0;
    for (int i = 0; i < N; ++i) {
        int V = A[i], count = 0;
        for (int j = 0; j < N; ++j) {
            if (A[j] == V) {
                ++count;
            }
        }
        if (count > majorityCount) {
            majorityCount = count;
            majority = V;
        }
    }
    return majority;
}  // '프로그래밍 대회에서 배우는 알고리즘 문제해결 전략 - 구종만' 에서 인용
~~~

위 코드는 N번 수행하는 for문이 이중 for문 구조를 가지고 있으므로 N^2번 수행된다. 따라서 이 알고리즘의 수행 시간은 N^2이다.  

알고리즘의 시간복잡도 분석하는건 학과 수업에서도 들었지만 여전히 헷갈리는 부분이 많다. 위 알고리즘처럼 간단한건 계산이 쉽지만 내가 무작정 휘갈겨 놓은 코드를 분석하는 건 정말 머리 아프다. 처음 코드를 짤 때부터 이를 염두에 두고 짜야하는 걸까? 이런 답을 내리기에는 아직 경험이 너무 부족하다. 원래도 많이 부족했지만 3년정도 코딩을 쉬다가 잡으니 더 어렵게만 느껴진다. 오늘로 끝이 아니라 꾸준히 해야 할텐데..  

책의 앞부분에선 개관과 알고리즘 시간복잡도 분석, 정당성 증명과 같은 내용을 소개하고 있다. 너무 필요한 내용이고 유익하겠지만 문제 풀이 경험이 많이 없는 나에겐 별로 와닿지 않고 지루하게만 느껴진다. 그래서 이 부분은 경험을 좀 쌓고 다시 읽어보기로 했다. 중간부부터 있는 예제와 문제들을 시간을 정해 풀어보고 풀이하며 공부해야겠다.  

---

#### 무식하게 풀기 (brute-force)

재귀 호출은 기저 사례(base case)에 도달 했을 때 답을 곧장 반환하는 조건문을 포함해야 한다. 그렇지 않으면 무한 루프가 돌 수 있다. base case에 해당할 때 return하는 조건문은 함수의 시작부에 넣는 게 좋다.  

n개의 원소 중 m개를 고르는 모든 조합을 찾는 알고리즘  
~~~cpp
// n: 전체 원소의 수
// picked: 지금까지 고른 원소들의 번호
// toPick: 더 고를 원소의 수
// 일 때, 앞으로 toPick개의 원소를 고르는 모든 방법을 출력한다.
void pick(int n, vector<int>& picked, int toPick) {
    // 기저 사례: 더 고를 원소가 없을 때 고른 원소들을 출력한다.
    if (toPick == 0) { printPicked(picked); return; }
    // 고를 수 있는 가장 작은 번호를 계산한다.
    int smallest = picked.empty() ? 0 : picked.back() + 1;
    // 이 단계에서 원소 하나를 고른다.
    for (int next = smallest; next < n; ++next) {
        picked.push_back(next);
        pick(n, picked, toPick - 1);
        picked.pop_back();
    } 
}  // '프로그래밍 대회에서 배우는 알고리즘 문제해결 전략 - 구종만' 에서 인용
~~~
위 알고리즘은 재귀함수를 이용하여 조합을 찾는 기본적인 알고리즘으로 책에 소개되어 있는 내용이다. 구조가 단순해서 외워두면 유용하게 쓸 수 있을 것 같다. 물론 난 전혀 생각 못한 방법이다...  

어떤 문제를 완전 탐색으로 해결하기 위해 필요한 과정  
1. 완전탐색 알고리즘의 걸리는 시간은 __가능한 답의 수에 정확히 비례__한다. 따라서 최대 크기의 입력을 가정했을 때 답의 개수를 계산하고 이들을 모두 제한 시간 안에 생성할 수 있을지를 가늠해본다.
2. 가능한 모든 답의 후보를 만드는 과정을 __여러개의 선택__으로 나눈다.
3. 하나의 조각으로 답의 일부를 만들고, 나머지 답을 __재귀 호출을 통해 완성__한다.
4. 조각이 하나밖에 없거나, 아예 남지 않은 경우는 답을 생성했으므로 __기저 사례__로 선택해 처리한다.
  
  

책의 예제문제를 몇개 풀어봤는데..... 너무 어렵다....  
백준같은 곳에서 낮은 난이도 문제부터 풀어보고 다시 책으로 공부해야할 것 같다....  

오늘은 여기까지  