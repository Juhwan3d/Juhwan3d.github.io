---
title: "[Algorithm] 분할 정복 (Divide & Conquer)"
date: 2023-01-12
categories: [Public]
tags: [algorithm]
---

_'프로그래밍 대회에서 배우는 알고리즘 문제해결 전략 - 구종만' 참조_  

---

#### 분할 정복이란<br>

분할 정복이란 말그대로 문제를 분할한 뒤 정복하는 알고리즘 디자인 패러다임이다. 다시 말하자면, 주어진 문제를 둘 이상의 부분 문제로 분할한 뒤 재귀 호출을 이용해 각 부분 문제를 계산하고, 각 부분 문제의 답으로부터 전체 문제의 답을 계산해 내는 방식이다. 단, 각 부분 문제의 크기를 거의 비슷하게 분할한다는 점이 일반적인 재귀 호출과는 다른 점이다.<br>
분할정복을 사용하는 알고리즘은 대게 세 가지의 구성요소를 가지고 있다.<br>

- 문제를 더 작은 문제로 분할하는 과정\(divide\)
- 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정\(merge\)
- 더이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제\(base case\)

또한 분할 정복을 적용하기 위해서는 문제를 둘 이상의 부분 문제로 나누는 자연스러운 방법이 있어야하고, 부분 문제의 답을 조합해 원래 문제의 답을 구하는 효율적인 방법이 있어야 한다.<br>

---

분할 정복은 많은 경우에 같은 작업을 더 빠르게 처리할 수 있다.<br>

예시 - 1부터 n까지의 합\(n\!\)을 구하는 분할 정복 알고리즘<br>

~~~cpp
// 필수 조건: n은 자연수
// 1 + 2 + ... + n을 반환한다.
int fastSum(int n) {
    // 기저 사례
    if (n == 1) return 1;
    if (n % 2 == 1) return fastSum(n-1) + n;  // 홀수인 경우 반으로 나눌 수 없으므로 n-1까지의 합과 n을 더해 값을 구한다.
    return 2*fastSum(n/2) + (n/2)*(n/2);  // 짝수인 경우 반으로 나눠 1 ~ n/2의 합과 (n/2)+1 ~ n까지의 합을 서로 더한다. (식을 정리하면 이런 형태가 된다.)
}  // '프로그래밍 대회에서 배우는 알고리즘 문제해결 전략 - 구종만' 에서 인용
~~~

\-\> 이 알고리즘은 짝수마다 n이 절반으로 줄어들기 때문에 n번 호출하는 완전탐색 알고리즘보다 시간 복잡도가 훨씬 낮다.

* 홀수일 때 절반에 근사한 값(예를들어 15라면 7과 8로 분할)으로 분할하지 않고 1을 빼서 짝수로 만드는 이유
    - 실제로 문제의 크기가 매번 절반으로 줄어든다면 기저사례에 도달하기까지 걸리는 분할 횟수가 줄어들기 때문에 대부분의 분할 정복 알고리즘은 가능한 절반에 가깝게 분할하고자 한다. 다만, **부분 문제가 중복**될 수 있으므로 주의가 필요하다.<br>


---

#### 병합 정렬\(Merge sort\)과 퀵 정렬(Quick sort)<br>

주어진 수열을 크기 순으로 정렬하는 문제는 정말 자주 쓰이고 유명한 문제이다. 이 문제를 해결하는 수많은 알고리즘 중 가장 널리 쓰이는 것이 병합 정렬과 퀵 정렬이고, 이 두 알고리즘은 모두 분할 정복 패러다임을 기반으로 만들어진 것들이다.<br>

병합 정렬은 주어진 수열을 가운데에서 쪼개 비슷한 크기의 수열 두개로 만든 뒤 이들을 재귀 호출을 이용해 각각 정렬한다. 그후 정렬된 부분 배열들을 하나로 합침\(Merge\)으로써 정렬된 전체 수열을 얻는다.<br>
퀵 정렬은 배열에 있는 수 중 임의로 '기준 수\(pivot\)'를 정하고 기준보다 작거나 같으면 왼쪽, 크면 오른쪽에 정렬하는\(오름차순 정렬일 경우\) 알고리즘이다.<br>

병합 정렬은 문제를 분할하는 과정에선 단순히 절반으로 분할만 하므로 O\(1\)의 시간 복잡도를 가진다. 하지만 병합하는 과정에서 별도의 병합과정을 거치므로 O\(n\)의 시간 복잡도를 가진다. 반면 퀵 정렬은 분할하는 과정에서 배열을 정렬하므로 O\(n\)의 시간 복잡도를 가지고, 병합하는 과정에선 O\(1\)의 시간 복잡도를 가진다.<br>
