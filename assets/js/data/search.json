[ { "title": "가사 모음", "url": "/posts/quietTime/", "categories": "Private", "tags": "think", "date": "2023-06-08 00:00:00 +0900", "snippet": "쓰다 남은 위로라면 그냥 지나가도 돼사랑없이 사는 것도 들먹이진 말아줘나를 보면 지금보다 울먹이지 말도록결혼 - 문문특별하다고 한 너는 사실 똑같더라고특별함이 하나 둘 모이면평범함이 되고우두커니 서서 세상을 가만히 내려다보면비극은 언제나 발 뻗고 잘 때쯤 찾아온단다아아아아슬퍼라김철수 씨 이야기 - 허회경난 몇마디의 말과 몇 번의 손짓에또 몇개의 표정과 흐르는 마음에울고 웃는 그런 나약한 인간일 뿐인데대체 내게서 뭐를 더 바라나요한계 - 백예린" }, { "title": "[Algorithm] 분할 정복 (Divide & Conquer)", "url": "/posts/divide-conquer/", "categories": "Public", "tags": "algorithm", "date": "2023-01-12 00:00:00 +0900", "snippet": "‘프로그래밍 대회에서 배우는 알고리즘 문제해결 전략 - 구종만’ 참조분할 정복이란분할 정복이란 말그대로 문제를 분할한 뒤 정복하는 알고리즘 디자인 패러다임이다. 다시 말하자면, 주어진 문제를 둘 이상의 부분 문제로 분할한 뒤 재귀 호출을 이용해 각 부분 문제를 계산하고, 각 부분 문제의 답으로부터 전체 문제의 답을 계산해 내는 방식이다. 단, 각 부분 문제의 크기를 거의 비슷하게 분할한다는 점이 일반적인 재귀 호출과는 다른 점이다.분할정복을 사용하는 알고리즘은 대게 세 가지의 구성요소를 가지고 있다. 문제를 더 작은 문제로 분할하는 과정(divide) 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정(merge) 더이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제(base case)또한 분할 정복을 적용하기 위해서는 문제를 둘 이상의 부분 문제로 나누는 자연스러운 방법이 있어야하고, 부분 문제의 답을 조합해 원래 문제의 답을 구하는 효율적인 방법이 있어야 한다.분할 정복은 많은 경우에 같은 작업을 더 빠르게 처리할 수 있다.예시 - 1부터 n까지의 합(n!)을 구하는 분할 정복 알고리즘// 필수 조건: n은 자연수// 1 + 2 + ... + n을 반환한다.int fastSum(int n) { // 기저 사례 if (n == 1) return 1; if (n % 2 == 1) return fastSum(n-1) + n; // 홀수인 경우 반으로 나눌 수 없으므로 n-1까지의 합과 n을 더해 값을 구한다. return 2*fastSum(n/2) + (n/2)*(n/2); // 짝수인 경우 반으로 나눠 1 ~ n/2의 합과 (n/2)+1 ~ n까지의 합을 서로 더한다. (식을 정리하면 이런 형태가 된다.)} // '프로그래밍 대회에서 배우는 알고리즘 문제해결 전략 - 구종만' 에서 인용-&gt; 이 알고리즘은 짝수마다 n이 절반으로 줄어들기 때문에 n번 호출하는 완전탐색 알고리즘보다 시간 복잡도가 훨씬 낮다. 홀수일 때 절반에 근사한 값(예를들어 15라면 7과 8로 분할)으로 분할하지 않고 1을 빼서 짝수로 만드는 이유 실제로 문제의 크기가 매번 절반으로 줄어든다면 기저사례에 도달하기까지 걸리는 분할 횟수가 줄어들기 때문에 대부분의 분할 정복 알고리즘은 가능한 절반에 가깝게 분할하고자 한다. 다만, 부분 문제가 중복될 수 있으므로 주의가 필요하다. 병합 정렬(Merge sort)과 퀵 정렬(Quick sort)주어진 수열을 크기 순으로 정렬하는 문제는 정말 자주 쓰이고 유명한 문제이다. 이 문제를 해결하는 수많은 알고리즘 중 가장 널리 쓰이는 것이 병합 정렬과 퀵 정렬이고, 이 두 알고리즘은 모두 분할 정복 패러다임을 기반으로 만들어진 것들이다.병합 정렬은 주어진 수열을 가운데에서 쪼개 비슷한 크기의 수열 두개로 만든 뒤 이들을 재귀 호출을 이용해 각각 정렬한다. 그후 정렬된 부분 배열들을 하나로 합침(Merge)으로써 정렬된 전체 수열을 얻는다.퀵 정렬은 배열에 있는 수 중 임의로 ‘기준 수(pivot)‘를 정하고 기준보다 작거나 같으면 왼쪽, 크면 오른쪽에 정렬하는(오름차순 정렬일 경우) 알고리즘이다.병합 정렬은 문제를 분할하는 과정에선 단순히 절반으로 분할만 하므로 O(1)의 시간 복잡도를 가진다. 하지만 병합하는 과정에서 별도의 병합과정을 거치므로 O(n)의 시간 복잡도를 가진다. 반면 퀵 정렬은 분할하는 과정에서 배열을 정렬하므로 O(n)의 시간 복잡도를 가지고, 병합하는 과정에선 O(1)의 시간 복잡도를 가진다." }, { "title": "[Algorithm] algospot 문제 풀이 (문제 ID: PICNIC)", "url": "/posts/picnic/", "categories": "Public", "tags": "algorithm", "date": "2023-01-11 00:00:00 +0900", "snippet": "‘프로그래밍 대회에서 배우는 알고리즘 문제해결 전략 - 구종만’ 참조문제 링크문제 풀이 과정알고리즘의 기본이라고 할 수 있는 완전탐색 알고리즘(브루트 포스) 문제이다. 재귀 함수를 이용해 완전탐색을 구현했다.처음엔 함수를 다음과 같이 구성했다.void countPairing(vector&lt;vector&lt;bool&gt;&gt;&amp; pairTable, vector&lt;int&gt;&amp; students, int&amp; ret, bool isPair) {\tif (!isPair) return;\tif (students.empty() &amp;&amp; isPair) { ret++; return; }\tfor (int i = 0; i &lt; students.size() - 1; i++) {\t\tfor (int j = i + 1; j &lt; students.size(); j++) {\t\t\tint s1 = students[i]; int s2 = students[j];\t\t\tisPair = pairTable[s1][s2];\t\t\tstudents.erase(students.begin() + j); students.erase(students.begin() + i);\t\t\tcountPairing(pairTable, students, ret, isPair);\t\t\tstudents.insert(students.begin() + i, s1), students.insert(students.begin() + j, s2);\t\t}\t}}배열 students는 학생들의 정보를 담고 있다(학생이 6명이면 [0, 1, 2, 3, 4, 5]). pairTable은 학생들의 친구 여부를 담고 있다. 내가 생각한 알고리즘은 배열의 맨 앞부터 두명의 학생을 선택하여 두 학생이 서로 친구라면 두 명의 학생을 배열에서 제외하고 같은 과정을 진행하는 것이었다. 하지만 이 문제는 학생들을 고르는 순서는 상관없으므로 위와 같은 코드는 너무 많은 중복을 일으켰다. ([0, 1][2, 3][4, 5]를 선택하는 경우와 [2, 3][0, 1][4, 5]를 고르는 경우를 다르게 인식함)그래서 코드를 다음과 같이 수정했다.void countPairing(vector&lt;vector&lt;bool&gt;&gt;&amp; pairTable, vector&lt;int&gt;&amp; students, int&amp; ret, bool isPair) {\tif (!isPair) return;\tif (students.empty() &amp;&amp; isPair) { ret++; return; }\t\tfor (int i = 1; i &lt; students.size(); i++) {\t\tint s1 = students[0]; int s2 = students[i];\t\tisPair = pairTable[s1][s2];\t\tstudents.erase(students.begin() + i); students.erase(students.begin());\t\tcountPairing(pairTable, students, ret, isPair);\t\tstudents.insert(students.begin(), s1), students.insert(students.begin() + i, s2);\t}}중복은 제거됐지만 여전히 값이 이상했다. 한참을 디버깅 한 끝에 원인을 찾을 수 있었다. 0과 3이 친구인지 확인하려면 pairTable[0][3]과 pairTable[3][0]중 하나의 값만 true면 되는데, isPair = pairTable[s1][s2]; 는 pairTable[0][3]의 경우만 확인하고 있기 때문이었다. 그래서 isPair = pairTable[s1][s2] + pairTable[s2][s1]; 으로 수정했다.아래는 성공한 코드 전문이다.#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void countPairing(vector&lt;vector&lt;bool&gt;&gt;&amp; pairTable, vector&lt;int&gt;&amp; students, int&amp; ret, bool isPair=true);int main() {\tint testCase;\tcin &gt;&gt; testCase;\t\tint studentCount, pairCount;\tvector&lt;int&gt; output;\tfor (int i = 0; i &lt; testCase; i++) {\t\tcin &gt;&gt; studentCount &gt;&gt; pairCount;\t\tvector&lt;vector&lt;bool&gt;&gt; pairTable(studentCount, vector&lt;bool&gt;(studentCount));\t\tfor (int i = 0; i &lt; pairCount; i++) {\t\t\tint x, y; cin &gt;&gt; x &gt;&gt; y;\t\t\tpairTable[x][y] = true;\t\t}\t\tvector&lt;int&gt; students; for (int i = 0; i &lt; studentCount; i++) students.push_back(i);\t\tint ret = 0;\t\tcountPairing(pairTable, students, ret);\t\toutput.push_back(ret);\t}\tfor (int elem : output) cout &lt;&lt; elem &lt;&lt; endl;}void countPairing(vector&lt;vector&lt;bool&gt;&gt;&amp; pairTable, vector&lt;int&gt;&amp; students, int&amp; ret, bool isPair) {\tif (!isPair) return;\tif (students.empty()) { ret++; return; }\t\tfor (int i = 1; i &lt; students.size(); i++) {\t\tint s1 = students[0]; int s2 = students[i];\t\tisPair = pairTable[s1][s2] + pairTable[s2][s1];\t\tstudents.erase(students.begin() + i); students.erase(students.begin());\t\tcountPairing(pairTable, students, ret, isPair);\t\tstudents.insert(students.begin(), s1), students.insert(students.begin() + i, s2);\t}}" }, { "title": "[Algorithm] 백준 문제 풀이 (1002번 터렛)", "url": "/posts/turret/", "categories": "Public", "tags": "algorithm", "date": "2023-01-04 00:00:00 +0900", "snippet": "문제 링크문제 풀이 과정이전에 알고리즘 공부를 시작하면서 구종만님의 _‘프로그래밍 대회에서 배우는 알고리즘 문제해결전략 (일명 종만북)’_으로 알고리즘 공부를 해보려고 했지만.. 베이스가 전혀 없는 상태로 시작하려니 어렵고 내용이 와닿지도 않았다..그래서 우선 쉬운 문제부터 풀어보면서 코딩이 좀 익숙해진 다음에 다시 책을 보기로 했다.터렛이라는 제목을 가진 이 문제는 단순히 두 원의 중심좌표 (x1, y1), (x2, y2)와 반지름 r1, r2가 주어질 때 두 원의 교점의 수를 계산하는 문제이다.두 원의 위치관계는 다음 중 하나일 것이다. 두 원의 중심과 반지름이 서로 같은 경우 -&gt; 교점이 무한대 두 원의 중심 사이의 거리가 각 반지름의 합보다 작고 차보다 클 때 (r2 - r1 &lt; d &lt; r2 + r1) -&gt; 교점 2개 두 원의 중심 사이의 거리가 각 반지름의 합과 같거나(외접) 차와 같을 때(내접) -&gt; 교점 1개수학이 오랜만이라 원이 다른 원안에 들어있는 경우를 거르는 방법을 생각하는게 오래걸리긴 했지만 나름 빠르게 조건을 단순화 시켜서 금방 풀 수 있을 줄 알았다… 하지만 예시 입출력도 통과하고 구조적으로도 별 문제 없어보이는데 계속 오답이 나왔다. 문제는 거리를 계산할 때 제곱근을 한 것이 문제였다. 모든 변수를 int로 선언했기에 소수점에 의한 오차는 없을거라고 생각했었지만, 제곱근을 계산하면서 double로 반환된 값을 int로 변환하면서 값이 버림이 되는 바람에 == 연산자가 제대로 작동하지 못한 것이다.그래서 코드를 다음과 같이 수정했다.//수정 전int calcDistance(int x1, int x2, int y1, int y2, int r1, int r2) {\tint width = x2 - x1;\tint height = y2 - y1;\tint distance = sqrt(pow(width, 2) + pow(height, 2)); // 제곱근하면서 double형이 int형으로 강제 변환\treturn distance;}int countPoint(int x1, int x2, int y1, int y2, int r1, int r2) {\tif (x1 == x2 &amp;&amp; y1 == y2 &amp;&amp; r1 == r2)\t\treturn -1;\tint distance = calcDistance(x1, x2, y1, y2, r1, r2);\tint radiusDiff = abs(r2 - r1);\tint radiusSum = abs(r2 + r1);\tif (distance &lt; radiusSum &amp;&amp; distance &gt; radiusDiff) return 2;\tif (distance == radiusSum || distance == radiusDiff) return 1; // distance는 값이 버림됐었기에 값이 정확하지 않을 수 있음\treturn 0;}// 수정 후int calcDistance(int x1, int x2, int y1, int y2, int r1, int r2) {\tint width = x2 - x1;\tint height = y2 - y1;\tint distance = pow(width, 2) + pow(height, 2); // 제곱근을 하지 않고\treturn distance;}int countPoint(int x1, int x2, int y1, int y2, int r1, int r2) {\tif (x1 == x2 &amp;&amp; y1 == y2 &amp;&amp; r1 == r2)\t\treturn -1;\tint distance = calcDistance(x1, x2, y1, y2, r1, r2);\tint radiusDiff = pow(abs(r2 - r1), 2); // 반지름의 합과 차에 제곱을 해서 비교함\tint radiusSum = pow(abs(r2 + r1), 2);\tif (distance &lt; radiusSum &amp;&amp; distance &gt; radiusDiff) return 2;\tif (distance == radiusSum || distance == radiusDiff) return 1;\treturn 0;}수정하고 제출하니 정답처리 됐다.오랜만에 코딩을 했더니 변수 이름 정하기도 어렵다.. 이제라도 꾸준히해서 복학하기 전엔 감을 좀 찾을 수 있도록 해야겠다.전체 코드#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;int calcDistance(int x1, int x2, int y1, int y2, int r1, int r2);int countPoint(int x1, int x2, int y1, int y2, int r1, int r2);int main() {\tint testCase;\tcin &gt;&gt; testCase;\tint x1, x2, y1, y2, r1, r2;\tvector&lt;int&gt; output;\tfor (int i = 0; i &lt; testCase; i++) {\t\tcin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; r1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; r2;\t\toutput.push_back(countPoint(x1, x2, y1, y2, r1, r2));\t}\tfor (int elem : output)\t\tcout &lt;&lt; elem &lt;&lt; endl;}int calcDistance(int x1, int x2, int y1, int y2, int r1, int r2) {\tint width = x2 - x1;\tint height = y2 - y1;\tint distance = pow(width, 2) + pow(height, 2);\treturn distance;}int countPoint(int x1, int x2, int y1, int y2, int r1, int r2) {\tif (x1 == x2 &amp;&amp; y1 == y2 &amp;&amp; r1 == r2)\t\treturn -1;\tint distance = calcDistance(x1, x2, y1, y2, r1, r2);\tint radiusDiff = pow(abs(r2 - r1), 2);\tint radiusSum = pow(abs(r2 + r1), 2);\tif (distance &lt; radiusSum &amp;&amp; distance &gt; radiusDiff) return 2;\tif (distance == radiusSum || distance == radiusDiff) return 1;\treturn 0;}" }, { "title": "[Algorithm] 백준 문제 풀이 (2798번 블랙잭)", "url": "/posts/blackjack/", "categories": "Public", "tags": "algorithm", "date": "2023-01-04 00:00:00 +0900", "snippet": "문제 링크문제 풀이 과정이 문제는 이전에 종만북에서 살짝 공부했던 완전탐색 알고리즘을 써서 푸는 문제다. (물론 다른 방법도 있겠지만 브루트포스 알고리즘 카테고리에 있었다.)완전탐색 문제인 만큼 재귀함수를 이용해 풀기로 했다.base case는 다음과 같이 설정했다. 카드 3장의 합이 M보다 클 때 -&gt; 최대합을 업데이트하지 않고 그대로 반환한다. 카드 3장의 합이 M보다 작거나 같을 때 -&gt; 최대합과 비교하여 둘중 큰 값으로 최대합을 업데이트하고 반환한다.완전탐색 알고리즘은 아주 기초적인 알고리즘이기에 어렵지 않게 풀 수 있었다. 재귀함수를 설계하는건 늘 어려워서 고민을 하긴 했지만 이전에 공부했던 구조대로 코드를 구성하니 나름 수월하게 풀 수 있었다.전체 코드#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int calcMaxSum(int limit, vector&lt;int&gt;&amp; cards, int toPick=3, int sum=0, int next=0, int maxSum=-1);int main() {\tint cardCount, limit;\tcin &gt;&gt; cardCount &gt;&gt; limit;\tvector&lt;int&gt; cards;\tfor (int i = 0; i &lt; cardCount; i++) {\t\tint temp;\t\tcin &gt;&gt; temp;\t\tcards.push_back(temp);\t}\tcout &lt;&lt; calcMaxSum(limit, cards);}int calcMaxSum(int limit, vector&lt;int&gt;&amp; cards, int toPick, int sum, int next, int maxSum) {\tif (toPick == 0) {\t\tif (sum &gt; limit) return maxSum;\t\tif (sum &lt;= limit) {\t\t\tmaxSum = maxSum &lt; sum ? sum : maxSum;\t\t\treturn maxSum;\t\t}\t}\tfor (int i = next; i &lt; cards.size(); i++) {\t\tsum += cards[i];\t\tmaxSum = calcMaxSum(limit, cards, toPick - 1, sum, i + 1, maxSum);\t\tsum -= cards[i];\t}\treturn maxSum;}" }, { "title": "[Algorithm] 알고리즘 공부 1일차..", "url": "/posts/algorithm/", "categories": "Public", "tags": "algorithm", "date": "2023-01-02 00:00:00 +0900", "snippet": "‘프로그래밍 대회에서 배우는 알고리즘 문제해결 전략 - 구종만’ 참조문제를 읽기 위한 6단계 문제를 읽고 이해한다. 가장 기초적이고 중요하지만 많은 사람들이 당연하다고 여겨 무시하게 되는 단계. 하지만 문제를 잘못 이해하면 문제를 푸는 의미가 없다. 문제에서 요구하는 조건과 제약사항을 명확히 이해하는 것이 중요. 나도 종종 문제를 풀며 가장 많은 실수를 하는 부분이 아닌가 생각된다. 대부분의 문제가 수학 공식처럼 명확하게 주어지기보단 주어진 글 속에서 문제의 요구사항을 파악해야 하다보니 어려움이 생기는 것 같다. 문제를 익숙한 용어로 재정의한다. 재정의와 추상화. 현실 시계의 개념을 우리가 다루기 쉬운 수학적/전산학적 개념으로 표현하는 과정. 추상화를 잘해야 문제를 쉽게 풀 수 있다. 사실 그동안 문제를 풀면서 가장 어려운 부분이다. 아직 경험이 부족해서인지 몰라도 문제를 보고 바로바로 추상화시켜서 간단하게 풀어내는 사람들을 보면 신기할 따름이다. 추상화를 하는 공식이 있는 것도 아니다보니 경험을 쌓는 것이 중요할 것 같다. 어떻게 해결할지 계획을 세운다. 추상화된 문제에 대해 어떤 자료구조와 알고리즘을 사용해서 문제를 풀지 정하는 단계이다. 사실상 가장 중요한 단계. 너무 어렵다. 문제 사이트는 보통 알고리즘 별로 문제를 나눠놓다보니 해당 카테고리에 맞는 알고리즘을 사용해서 문제를 풀기 마련인데, 실제 대회나 테스트 문제를 풀어보면 어떤 알고리즘과 자료구조를 사용해야 할지 전혀 모르겠는 경우가 많다. 이 역시 경험으로 해결해야 할 것 같다. 계획을 검증한다. 계획을 검증한다. 모든 요구조건을 만족할 수 있는지 파악하고, 이때 수행시간과 사용 메모리 역시 확인한다. 제대로 검증하지 않고 코드를 짜다가 문제를 파악하면 이미 돌이킬 수 없을 정도로 시간이 지나있을 수 있다. 검증을 철저히 하자. 프로그램으로 구현한다. 실질적인 코딩과정. 계획한 알고리즘을 구현한다. 알고리즘을 구체적으로 설계해서 구현중에 알고리즘을 변경하는 일이 없도록 한다. 오타 좀 그만 쳐 제발… 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다. 대회/테스트가 끝나고 자신의 문제풀이를 돌아보고 개선하는 과정. 실력향상을 위해선 가장 중요한 단계다. 고등학교때도 오답노트는 정말 하기 싫었는데.. 여기서도 해야한다니.. 우울하다.. 한 문제당 30분 정도 시간 정해놓고 그 안에 못풀면 답안을 참고하자. 아직 초보니까.. 계속 한 문제만 붙잡고 고민하는 것보다 다른 사람의 코드를 참조해서 공부하는 것이 도움이 될 수 있다.이러니 저러니 말을 했지만 사실 프로그래밍 문제 풀이에 제일 중요한 건 경험인 것 같다. 책에 있는 문제들부터 쭉 풀어보고 다양한 알고리즘을 익힌 뒤에 문제 사이트에서 닥치는 대로 많이 풀어보자. 문제풀이 실력은 물론 알고리즘, 자료구조에 대한 이해, 단순 코딩 능력도 좋아질 것이다. 아마도…알고리즘의 시간 복잡도 분석알고리즘은 빠른게 좋다. 다만 이 빠르기가 단순히 프로그램의 실행 시간만을 이야기 하는 것은 아니다. 프로그램의 실행 시간은 프로그래밍 언어, 하드웨어, 운영체제, 컴파일러 등 알고리즘 외적인 수많은 요소에 영향을 받기 때문이다.또한 입력의 크기나 특성에 따라 같은 알고리즘이라도 프로그램의 실행 시간은 변하기 마련이다. 알고리즘의 수행 시간은 반복문에 따라 결정된다. 대부분의 알고리즘은 입력 횟수에 따라 반복문의 수행 횟수 역시 달라진다. 이런 알고리즘들은 입력 횟수가 커지면 커질수록 반복문이 수행 시간에서 차지하는 비중이 증가한다. 따라서 대개 우리는 알고리즘의 수행 시간을 반복문이 수행되는 횟수로 측정한다.int majority1(const vector&lt;int&gt;&amp; A) { int N = A.size(); int majority = -1, majorityCount = 0; for (int i = 0; i &lt; N; ++i) { int V = A[i], count = 0; for (int j = 0; j &lt; N; ++j) { if (A[j] == V) { ++count; } } if (count &gt; majorityCount) { majorityCount = count; majority = V; } } return majority;} // '프로그래밍 대회에서 배우는 알고리즘 문제해결 전략 - 구종만' 에서 인용위 코드는 N번 수행하는 for문이 이중 for문 구조를 가지고 있으므로 N^2번 수행된다. 따라서 이 알고리즘의 수행 시간은 N^2이다.알고리즘의 시간복잡도 분석하는건 학과 수업에서도 들었지만 여전히 헷갈리는 부분이 많다. 위 알고리즘처럼 간단한건 계산이 쉽지만 내가 무작정 휘갈겨 놓은 코드를 분석하는 건 정말 머리 아프다. 처음 코드를 짤 때부터 이를 염두에 두고 짜야하는 걸까? 이런 답을 내리기에는 아직 경험이 너무 부족하다. 원래도 많이 부족했지만 3년정도 코딩을 쉬다가 잡으니 더 어렵게만 느껴진다. 오늘로 끝이 아니라 꾸준히 해야 할텐데..책의 앞부분에선 개관과 알고리즘 시간복잡도 분석, 정당성 증명과 같은 내용을 소개하고 있다. 너무 필요한 내용이고 유익하겠지만 문제 풀이 경험이 많이 없는 나에겐 별로 와닿지 않고 지루하게만 느껴진다. 그래서 이 부분은 경험을 좀 쌓고 다시 읽어보기로 했다. 중간부부터 있는 예제와 문제들을 시간을 정해 풀어보고 풀이하며 공부해야겠다.무식하게 풀기 (brute-force)재귀 호출은 기저 사례(base case)에 도달 했을 때 답을 곧장 반환하는 조건문을 포함해야 한다. 그렇지 않으면 무한 루프가 돌 수 있다. base case에 해당할 때 return하는 조건문은 함수의 시작부에 넣는 게 좋다.n개의 원소 중 m개를 고르는 모든 조합을 찾는 알고리즘// n: 전체 원소의 수// picked: 지금까지 고른 원소들의 번호// toPick: 더 고를 원소의 수// 일 때, 앞으로 toPick개의 원소를 고르는 모든 방법을 출력한다.void pick(int n, vector&lt;int&gt;&amp; picked, int toPick) { // 기저 사례: 더 고를 원소가 없을 때 고른 원소들을 출력한다. if (toPick == 0) { printPicked(picked); return; } // 고를 수 있는 가장 작은 번호를 계산한다. int smallest = picked.empty() ? 0 : picked.back() + 1; // 이 단계에서 원소 하나를 고른다. for (int next = smallest; next &lt; n; ++next) { picked.push_back(next); pick(n, picked, toPick - 1); picked.pop_back(); } } // '프로그래밍 대회에서 배우는 알고리즘 문제해결 전략 - 구종만' 에서 인용위 알고리즘은 재귀함수를 이용하여 조합을 찾는 기본적인 알고리즘으로 책에 소개되어 있는 내용이다. 구조가 단순해서 외워두면 유용하게 쓸 수 있을 것 같다. 물론 난 전혀 생각 못한 방법이다…어떤 문제를 완전 탐색으로 해결하기 위해 필요한 과정 완전탐색 알고리즘의 걸리는 시간은 가능한 답의 수에 정확히 비례한다. 따라서 최대 크기의 입력을 가정했을 때 답의 개수를 계산하고 이들을 모두 제한 시간 안에 생성할 수 있을지를 가늠해본다. 가능한 모든 답의 후보를 만드는 과정을 여러개의 선택으로 나눈다. 하나의 조각으로 답의 일부를 만들고, 나머지 답을 재귀 호출을 통해 완성한다. 조각이 하나밖에 없거나, 아예 남지 않은 경우는 답을 생성했으므로 기저 사례로 선택해 처리한다.책의 예제문제를 몇개 풀어봤는데….. 너무 어렵다….백준같은 곳에서 낮은 난이도 문제부터 풀어보고 다시 책으로 공부해야할 것 같다….오늘은 여기까지" }, { "title": "2022 SW Festival 후기..", "url": "/posts/swfestival-review/", "categories": "Private", "tags": "blog", "date": "2022-11-30 00:00:00 +0900", "snippet": "소페..3월쯤 시작했던 소페 작업이 끝났다..19년도엔 대상도 받았던 대회라 올해도 참가하고 싶었는데 마침 제의가 들어와서 시작하게됐다..다만 문제는.. 어떤 프로젝트인지 제대로 물어보지 않고 시작했다는 것..난 분명 오브젝트 몇개만 만들어주면 된다고 들었고…. 그렇게 깃털보다 가벼운 마음으로 시작한 프로젝트였는데..팀원이 총 5명인줄 알았으면 시작 안했을텐데…조선시대가 배경인줄 알았으면 시작 안했을텐데…모델링이 아니라 레벨 디자인도 할 줄 알았으면 시작 안했을텐데…후…참 여러모로 아쉬운게 많은 프로젝트였다. 개발자 3명에 디자이너 2명(나 포함)이었는데 역시 큰 프로젝트가 아니면 개발인원은 적을수록 난이도가 내려가는 것 같다. 디자이너는……. 분명 많을수록 좋아야할텐데….. ~사실 디자이너는 나 1명이었을지도..~ 아무튼 배운게 아예 없진 않다. 나름 이번 프로젝트 하면서 모델도 많이 만들었고.. 기존에 관심있던 sci-fi풍이나 중세 유럽풍의 디자인이 아니라 조선시대풍의 모델링을 해보는 것도 좋은 경험이었다. (레퍼런스가 너무 없어서 고생을 좀 했지만..) 모델 구상부터 모델링/스컬핑, 텍스쳐링, 게임 엔진에 이식하는 것까지 혼자 해보면서 게임 에셋을 만들 때 어떤 워크플로를 따라야 할지 고민해볼 수 있는 나름 뜻깊은 시간이었다. 사실 이 프로젝트에서 만든 모델 중에 맘에 드는 건 장승 정도밖에 없다. 아무래도 내가 직접 구상해서 만들다보니 아이디어가 부족하기도 했고.. 시간에 쫒기면서 만들다보니 디테일을 넣기도 힘들었다.. 지금까지 올린 것들 말고도 만든게 많다. 차차 정리해서 포스팅할 생각이다. 물론 만들었다가 폐기된 모델들은 못올리겠지만.. 정리하면 이번 소페는 개인적으로 너무 아쉬웠다. 결과가 좋지 않았던건 맞지만 그것때문만은 아니다. 프로젝트를 진행하는 동안 한번도 내 게임에 재미를 느끼지 못해서 작업하는 내내 즐겁지가 않았다.. 소개페이지: https://github.com/mmindoong/2022SWFestival_KSWAG데모영상: https://www.youtube.com/watch?v=_UB4R-etXuI" }, { "title": "[3D] 장승", "url": "/posts/Jangseung/", "categories": "Public, 3D", "tags": "Rendered, blender, substance painter, environment, game asset", "date": "2022-08-19 00:00:00 +0900", "snippet": "장승장승이다.지금 개발중인 게임에 필요해서 만들었다.천하대장군과 지하여장군인데, 서로 대비되는 표정으로 재밌게 표현해보려고 한…거는 아니고 그냥 손가는대로 만들었다.아직 sculpting이 미숙해서 사람의 얼굴을 만드는 것이 걱정이었는데, 장승의 얼굴은 이상적인 사람의 얼굴이라기보단 뒤틀리고 기괴한 모습이 특징이라 오히려 더 쉬웠다.이전엔 substance 3d painter로 텍스쳐링을 할 때 그냥 스마트 마테리얼만 적당히 골라서 넣고 약간 수정을 하는 정도였다. 그래서 이번엔 텍스쳐링에도 신경을 써봤다. 그래봐야 curvature 맵을 이용해 dirt 좀 추가하고 글씨 쓰고.. 글씨 쓴 영역에 roughness랑 색감 좀 바꾼거 정도지만.. 아무튼 이전보단 많은 시간을 들였다.blender render기존에 이미지URL을 생성하기 위해 Essedrop 사이트를 이용해왔지만.. 벌써 무료 용량이 가득 차버렸다.. 다른 방법을 찾던지 유료로 업그레이드를 하던지 해야할거 같다…" }, { "title": "[3D] 솟대", "url": "/posts/Sotdae/", "categories": "Public, 3D", "tags": "Rendered, blender, substance painter, weapon, game asset", "date": "2022-06-15 00:00:00 +0900", "snippet": "솟대이건 솟대다. 옛날 마을 입구에 무더기로 서있는 그 솟대다.갑자기 솟대를 만든건 지금 개발중인 게임이 조선~고려시대 배경이라 마을 입구에 장승과 함께 세워놓으려고 만들었다.실루엣을 보면 알 수 있겠지만 꽤나 많은 폴리곤이 들어갔다. 무려 10000개가 넘는다. 고작 솟대 하나에 불필요하게 많은 폴리곤을 사용했다고 생각할 수 있지만, 난 UE5의 Nanite를 믿어보기로 했다.이전에 제작한 봉은 static mesh가 아니라 Nanite를 사용할 수 없어서 최대한 폴리곤을 줄여 가볍게 했지만, static mesh인 곳에는 아낌없이 폴리곤을 사용해볼 생각이다. 혹시나 Nanite를 적용하고도 퍼포먼스에 문제가 생기면 그때 줄일 생각이다..텍스쳐는 나무 베이스에 world space normal map을 이용해서 윗면에 초록색 이끼를 살짝 깔아주었다. 티가 날진 모르겠지만 솟대 아래쪽은 흙이 묻은 느낌을 내고 싶어서 dirt를 이용해 color와 height를 조금 주었다.substance painter나 ue5에서 볼 때랑 blender에서 렌더링 했을 때랑 텍스쳐 느낌이 좀 다른거 같다. blender가 좀 색이 날아가는 느낌이라고 해야할까? 렌더 설정 탓일 수도 있겠다. 기회가 되면 marmoset으로 렌더링하고 싶다. 한달 무료체험할 수 있던데 그거 먼저 해볼까 생각중이다.blender renderue5 screenshot" }, { "title": "[3D] 새로운 봉", "url": "/posts/Pole-Jade/", "categories": "Public, 3D", "tags": "Rendered, blender, substance painter, weapon, game asset", "date": "2022-06-15 00:00:00 +0900", "snippet": "이전에 만들었던 봉이 너무 여의봉 같은 느낌이 강해서 한국적인 배경에 어울리지 않았다. 그래서 다시 제작했다! 형태를 좀 더 단순화하고, 금보단 옥을 사용하여 한국적인 느낌을 주려고 했다.face count도 1970개로 대폭 줄였다.이전과 동일하게 blender로 모델링, 언래핑, 스컬핑, 렌더링을 했고, substance painter로 텍스쳐링했다.Face count - 1970UE5" }, { "title": "[3D] 봉 (Pole)", "url": "/posts/Modeling-Pole/", "categories": "Public, 3D", "tags": "Rendered, blender, substance painter, weapon, game asset", "date": "2022-04-27 00:00:00 +0900", "snippet": "봉!블로그를 개설하고 처음 올리는 모델링 포스팅은 봉이 되었다. 현재 진행중인 게임 개발 프로젝트에 들어갈 무기다. 조선의 도사가 사용하는 봉으로 제작 되었지만, 만들고 보니 너무 중국풍의 여의봉 느낌이 많이 나서 좀 아쉽다. 아무래도 무기로 사용되는 봉은 레퍼런스가 적어서 여의봉을 많이 참고한 것이 문제였던 것 같다. 사실 이 봉은 제작을 시작한지 굉장히 오래됐는데, 아이디어 부족으로 진행을 못하고 있었다. 일단 손 가는대로 만들고 나중에 수정하자는 생각으로 마무리 지은거라서, 디테일이 많이 부족하다. 이는 게임 개발이 진행되고 컨셉이 추가될 때마다 수정할 계획이다.substance painter는 여전히 어렵다.. 사실 컨셉아트는 고사하고 아이디어에 대한 정확한 구상 없이 무작정 작업을 시작하다보니 컨셉에 일관성이 없고 중구난방으로 마무리 된 것 같다. 모자란 그림 실력이지만, 간단하게라도 컨셉을 그려보고 텍스쳐링에 대한 구상까지 어느정도 해놓고 작업을 시작하는 습관을 들여야겠다..아래는 렌더링된 이미지이다. 렌더링은 blender에서 4k해상도로 진행했다.Pole (Face count - 12,144)지금은 bledner로 렌더링했지만, 언리얼로 렌더링 하는 방법도 공부해서 포스팅 해볼 계획이다." }, { "title": "First Posting!", "url": "/posts/First-Posting/", "categories": "Private, blog", "tags": "study, test", "date": "2022-04-27 00:00:00 +0900", "snippet": "첫 블로그, 첫 포스팅난 블로그를 만들어 본게 이번이 처음이다. (대학 입학할 때 개인 블로그 제출하라고 해서 급하게 만든 네이버 블로그를 제외하면) 당연히 jekyll, github page, markdown 등등 모두 처음 사용해본다. 심지어 HTML, CSS도 관련 지식이 없다.. 그러다 보니 지금 사용중인 이 jekyll theme chirpy theme를 적용하는 것도 쉽지 않은 일이었다. 꼬박 하루를 날렸다..원래는 Notion으로 간단하게 만들려고 했었는데, Notion이 생각보다 너무 단순하고 쉬웠다. 그래서 좀 어려운 방식에 도전해 보고 싶어서 github page로 만들었다. 덕분에 jekyll도 설치하고, WSL로 ruby, rubygem, bundler 등등 설치하는 재미가 있었다.테마를 적용하는 과정에선 생각보다 어려움이 많았는데, 다른 것들은 구글링으로 자료를 찾을 수 있었지만, 왼쪽 하단의 social link를 커스텀하는 방법은 도저히 찾을 수 없었다. 기본 테마 설정은 github, twitter, email, rss 이렇게 4가지인데, 난 twitter를 하지 않고, instagram, artstation 등의 링크를 넣고 싶었다. 다행히 chirpy theme에서 사용 중인 font awesome의 버전이 instagram, artstation의 아이콘을 모두 포함하고 있는 버전이라 아이콘을 추가하는 일은 어렵지 않았다. ‘/_data/contact.yml’에 접근해서 아래와 같은 코드를 삽입해주기만 하면 됐다.- type: instagram icon: 'fab fa-instagram'- type: artstation icon: 'fab fa-artstation'간단하게 icon을 추가해서 이제 링크만 연결하면 되겠다! 했는데, 이게 쉽지 않은 일이었다. ‘/_config.yml’의 social 부분을 아무리 수정해도 변함이 없었고, ‘/_site/index.html’의 350번 줄 즈음에 사이드바 버튼 부분에 아무리 링크를 추가해도 빌드 때마다 초기화 되었다. 그렇게 포기하려고 할 때 즈음 ‘/_includes/sidebar.html’ 파일이 눈에 띄었다. 누가봐도 사이드바에 관련된 파일명. 설레는 마음으로 파일을 열었을 땐 contact 엔트리 목록이 날 반겼다… 엔트리 목록에 원하는 사이트 타입과 주소를 넣고 빌드 후 확인 해보니 정상적으로 동작했다..! 진짜 너무 짜릿했다.아무튼 그렇게 해서 블로그 초기 설정이 대충 마무리 됐다. 사실 포스트도 영어로 깔끔하게 쓰고 싶었는데 영어로 글을 쓰는 재주는 없어서 포기했다.. 사실 markdown으로 글 작성 하는 것도 아직 버겁다.앞으로 계획이 블로그를 다른 사람이 볼지는 모르겠지만, 앞으로 포스팅 계획을 세워보려고 한다. 우선, 모델링 작업물들을 작업 과정과 어려웠던 점 등을 정리해서 올려볼 생각이다. 추가로 언리얼이나 c++같은 공부도 하게 된다면 공부 기록도 할 생각이다. 블로그를 개설한 이유가 재밌을거 같아서도 있지만, 공부 기록을 정리하려는 목적도 있었기 때문에, 기록하는 형식으로 포스팅 하려고 한다.markdown으로 처음 써보는 글이라 잘 써졌을 지 모르겠다. 지금은 vscode로 쓰는 중인데, 블로그에 푸시해보고 엄청 수정해야 할 것 같다ㅎㅎ;" } ]
